package ooday04;

/**
 * 匿名內部類的演示類 : 應用率高，要重點掌握!!!
 */
public class AnonInnerClassDemo {
    public static void main(String[] args) {
        /**
         * 匿名內部類時，系統自動完成了兩件事
         * 1)."創建了Aoo的派生類"，但是該類沒有名字!
         * 2).為該派稱類創造了一個對象，名為o1，並且"向上轉型為Aoo類型!"
         * 3).大括號中的內容為派生類的類體
         */
        Aoo o1 = new Aoo() {//匿名內部類
            /**
             * 既是派生類(子類)，則超類(父類)中的抽象方法必須重寫完整
             */
            @Override
            void show() {
                System.out.println("此處已調用o1.show()的方法...");
            }
        };

        /**
         * 匿名內部類時，系統自動完成了兩件事
         * 1)."創建了Aoo的派生類"，但是該類沒有名字!
         * 2).為該派稱類創造了一個對象，名為o2，並且"向上轉型為Aoo類型!"
         * 3).大括號中的內容為派生類的類體
         */
        Aoo o2 = new Aoo() {//匿名內部類
            /**
             * 既是派生類(子類)，則超類(父類)中的抽象方法必須重寫完整
             */
            @Override
            void show() {
                System.out.println("此處已調用o2.show()的方法...");
            }
        };

        /**
         * 可以生成非常多次的 new Aoo(){}
         * 但本質上是產生Aoo無數個新的派生類然後再創建該類對象
         * 因此o1,o2...等匿名內部類對象之間，其實並沒有關係!!!!!
         * 另外要特別注意 : 匿名內部類不可以修改外部成員變量的值!!!!!!
         */

        /**
         * 調用匿名內部類的資源，則直接使用該派生類的對象調用即可
         */
        o1.show();
        o2.show();
    }
}


abstract class Aoo {
    abstract void show();
}
